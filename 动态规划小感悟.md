```
动态规划：多个元素随意组合成局部最优解。动态规划一般用于每一步都有多种选择，与前面的选择有关，如果选择的次数有限，比如折扣，只允许使用n次折扣这种，最好还是使用dfs，但是对于选择有1次或2次选择次数的（次数少且固定），还是可以使用动态规划的，比如这道题：https://leetcode.cn/problems/reverse-bits-lcci/solution/dong-tai-gui-hua-you-hua-0ms-by-dralamog-egzo/
当动态规划遇到了计算有多少种情况类似的问题时，需要保证选择的有序性，例如找硬币，假设要找3元，可动用的硬币可以为1和2，我可以使用动态规划dp[3]=dp[1]+dp[2]（表示在金额为1的基础上最后一个硬币选择2元硬币,在金额为2的基础上最后一个硬币选择1元硬币），这样dp[3]=2,但是这里没有按安排好1和2的出场顺序，也就是说这样计算明明只是选了1和2这两个硬币，却出现了两种情况，那就不行，那么我们需要让最后一个硬币必须大于等于之前选的硬币，如何实现呢？
错误示范：
        for (int i = 0; i <= amount; i++) {
            for (int coin:coins) {
                if(i>=coin){
                    dp[i] += dp[i - coin];
                }
            }
        }
外层循环为金额，内层为硬币种类时就会出现之前说的错误，应该要这样：
        for (int coin : coins) {
            for (int i = coin; i <= amount; i++) {
                dp[i] += dp[i - coin];
            }
        }
外层为硬币，内层为金额，这样所有的可能中最后一个硬币就会大于等于之前选择的硬币，因为当前值是由之前选了比当前硬币小的所有可能性得到的，稳得一批。
```

```
对于绝大多数动态规划而言，不是从前面算，之后得到结果推出下一个位置的最优解，还是从后面算，推出前面一位的最优解，都是单方向的，那问题来了，如果当前值的维护需要双方向如何是好？
```

例题：

给定一个布尔表达式和一个期望的布尔结果 result，布尔表达式由 0 (false)、1 (true)、& (AND)、 | (OR) 和 ^ (XOR) 符号组成。实现一个函数，算出有几种可使该表达式得出 result 值的括号方法。

```java
class Solution {
    public int countEval(String s, int result) {
        int n = s.length();
        int[][][] dp = new int[n][n][2];
        for (int i = 0; i < n; i++) {
            dp[i][i][0] = (s.charAt(i) - '0' == 0 ? 1 : 0);
            dp[i][i][1] = (s.charAt(i) - '0' == 1 ? 1 : 0);
        }
        for (int len = 2; len <= n; len++) {
            for (int l = 0; l + (len - 1) < n; l++) {
                int r = l + (len - 1);
                for (int i = l; i <= r; i++) {
                    char c = s.charAt(i);
                    if (c == '&') {
                        dp[l][r][0] += dp[l][i - 1][0] * dp[i + 1][r][0] + dp[l][i - 1][0] * dp[i + 1][r][1] + dp[l][i - 1][1] * dp[i + 1][r][0];
                        dp[l][r][1] += dp[l][i - 1][1] * dp[i + 1][r][1];
                    }
                    if (c == '|') {
                        dp[l][r][0] += dp[l][i - 1][0] * dp[i + 1][r][0];
                        dp[l][r][1] += dp[l][i - 1][0] * dp[i + 1][r][1] + dp[l][i - 1][1] * dp[i + 1][r][0] + dp[l][i - 1][1] * dp[i + 1][r][1];
                    }
                    if (c == '^') {
                        dp[l][r][0] += dp[l][i - 1][0] * dp[i + 1][r][0] + dp[l][i - 1][1] * dp[i + 1][r][1];
                        dp[l][r][1] += dp[l][i - 1][0] * dp[i + 1][r][1] + dp[l][i - 1][1] * dp[i + 1][r][0];
                    }
                }
            }
        }
        return dp[0][n - 1][result];
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        solution.countEval("1^0|0|1",0);
    }
}
```

```
所以说，如果是双方向的，由双方向推出中间结果，那么我们可以界定一个区域范围，比如当前范围2，由范围为1的左右两个范围（已知）共同推出范围为2的结果（上面例题是由两边为1的范围推出范围为3的结果），然后从前往后把所有范围为2的结果都保存，为范围为3的计算做好准备。最后就可以算出范围为n的结果了。
```

```
动态规划和背包问题其实本质区别在于动态规划包括以自身为纬度的规划，背包问题包括了以整体为纬度的规划，比如动态规划要求在一条x轴上有多条线段，每条线段有各自的价值，求不重叠时的最大价值，在这个时候我们可以以线段自身为纬度，比如dp[i]表示我现在维护到线段i这里，然后我根据前面不重叠的线段的dp[j]来维护我的dp[i]，但是背包问题更多的是比如我的背包的最大重量，体积这些整体纬度来维护dp。
```

```
动态规划其实分为序列dp和状态dp，比如dp[0][i]，dp[1][i]表示第i家拿与不拿，拿与不拿是分开的，0，1就是状态，当然打家劫舍那道题也可以使用dp[i]表示第i家拿与不拿，拿与不拿是合并的。
这两者的选择很简单，如果比如说我拿当前商品的折扣价必须上一个商品拿原价的这种问题，那我最好使用状态dp，但是如果我该商品拿不拿折扣与之前拿不拿折扣无关，只与总的折扣卷有关，那我完全可以用状态dp和序列dp，但是相比而言这种情况下还是用序列dp会比较好一些，因为使用状态dp你得拿到上一个商品所有拿与不拿的状态的最大或者最小值，然后在此基础上加上该商品，还得维护多个状态，但是序列dp却把多个状态包含在一起，所以使用序列dp会比较好。
还有一种题需要你输出你的选择，比如上面的打家劫舍问题，我们最好使用序列dp，dp[i]包含了拿与不拿，那我们就可以通过if(dp[i]=dp[i-1]+1)知道我当前的i拿了，从而可以从后往前推得到打劫了那几家，还有之气有一道题求两个字符串的最长不连续子字符串，也是先计算出dp[i][j](i表示str1当前的下标，j表示str2当前的下标)，那我也可以求出之后从右下角往左上角推。如果是状态dp，就比较麻烦了。
```

```
商品本身约束讲解：如果商品本身要求你如果拿了1号商品这件商品后面的k件商品都不能拿（这个区间由商品本身决定，区间如果是固定的到是没下面所说的影响），那么这种题最好从后面往前遍历，因为当遍历到该商品时，你知道应该往后跳几位拿取商品，但是假设从前往后拿，那么前面商品拿了对拿这件商品是有影响的，你得去看看哪件商品拿了不妨碍我拿这件商品，那哪件商品才能拿，但是这种的需要使用状态dp，毕竟如果是序列dp是包含了拿与不拿，你也不知道它拿了没有，会不会对拿这件商品有影响。但是如果是拿了该商品，那么前后的k范围内的商品都不能拿，并且所有商品的k值都相同，那么从前往后还是从后往前就没有什么区别了，
```

```
看到什么题可以想到动态规划呢？
就是那种牵一发而动全身的基本都是dp，比如n个玩具打包，那么我把1~k打包还是1~k+1打包会影响后面的打包情况，这种就得用到dp,这种问题可以使用dp划分打包范围，比如1~k个商品的打包就等于1~k-1或1~k-2或1~k-3......中最小花销加上剩余部分打包的花销（看题目给的是什么），取最优解就是当前dp[i]的最优解。
```

```
在dp的时候尽可能把情况分开，比如说TJ??U,其中？可以变成任意字符，问字符串包含TJU的情况有多少种？
思考：我可以设置dp[i][0]表示直到下标i仍不包含TJU的匹配的情况，dp[i][1]表示直到下标i包含TJU的情况
那么你就得去考虑当i前面是什么的时候，dp[i][0]和dp[i][1]该怎么走，这样子情况就很多了，那么我们可以更加细化一点，比如dp[i][0]表示当前字符串以T为后缀且还没匹配的方案数，dp[i][1]表示当前字符串以TJ为后缀且还没匹配的方案数，dp[i][2]表示当前完全匹配的方案数，这样把情况细化出来，情况就会少很多，你只需要考虑当前i位置的是什么就好了，而不需要罗列i前面是什么的情况。
```

贪心：

贪心和动态规划比较大的一个区别就是贪心一般都是拿上一个结果来计算，而动态规划一般拿前面的所有情况多有可能拿来计算，简单来说就是一个走一步算一步，而且只记录自己当前走的那一步（也可能不止一步，但一般不多），dp一般记录自己所走的每一步，每一步都有可能用于后面的计算。

贪心技巧：贪心所走的这一步一般就是当前走到这一步为止的最优解，即便是再走一步也是在这个最优解的基础上去算的，你不用去考虑如果上上步走的不一样会不会影响到我现在所走的这一步，因为贪心保证了前面所走的所有步都是最优的。而dp不一样，dp之所以要保存之前所走的每一步就是因为dp不敢保证上一步是不是走的正确，举个例子：比如我这一步有四条路可以走。贪心可以根据之前的最优结果算出我这一步要怎么走，而且那么走一定是当前最优解，而dp则是记录下四条路分别走都是什么结果，下一步就可以根据之前四条路不同的结果继续记录下一步每种选择的不同结果。

总结：贪心所走的每一步一定是当前最优解，不会出现在不走出下一步前这一步是最优解，但在有下一步存在的情况下这一步不一定是全局最优解的情况。

![image-20230924183714505](D:\typora\笔记\习题笔记\imagesr\image-20230924183714505.png)

输出：2

代码：

解释：

```
当前这个士兵能往左则往左，不能则尝试往右，否则不动，当前士兵就算往右也最多就是导致下一个不能往左，也就是最坏的情况就是我们只有一个能躺下（在不考虑第二个右躺的情况下），所以按照上面的方法去贪心一定是最优解。
```

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        int[] x = new int[n];
        int[] h = new int[n];

        for (int i = 0; i < n; ++i) {
            x[i] = sc.nextInt();
            h[i] = sc.nextInt();
        }

        int ans = 1;
        int R = x[0];

        for (int i = 1; i < n; ++i) {
            if (x[i] - h[i] > R) {
                R = x[i];
                ans += 1;
            } else {
                if (i + 1 == n || x[i] + h[i] < x[i + 1]) {
                    R = x[i] + h[i];
                    ans += 1;
                } else {
                    R = x[i];
                }
            }
        }

        System.out.println(ans);
    }
}

```

dp和dfs的选择问题：

面临多可能性问题，我们应该想到dp和dfs，dp的选择更多是每一步，每一种可能都得走，所以往往时间复杂度还不算低，但dp记录了之前每一步的结果，从而推断出这一步的结果，所以具体的时间复杂度还得看题目而定，dfs也是每一步都去走，但是dfs+记忆数组的情况大多要比dp来得少，所以建议看到类似题两种方法都思考一下，但不可否认，在dfs不能使用记忆数组的场景下  ，还是dp更香。

dp有时候不是我当前dpi,j去拉取别人的值，而是别人的值来维护我当前值，我总结为传统意义上的那种是pull拉取，我dpi,j需要去从dpi-1,j-1子类的前面维护好的数据求的，但是还有一种push推的方式，其实就是别人的值维护好了之后更新后面的值，比如dpi,j的时候维护dp(i+1,j+1);dp(i+2,j+2)的值，例题：

![image-20231023093427483](D:\typora\笔记\习题笔记\imagesr\image-20231023093427483.png)

```
输入：                                 输出：                                   
4 3                                   2
...
.*.
...
**.
```

```c++
while i + k < n and isvisit[i+k][j] != -1 and (isvisit[i+k][j])^1:
            isvisit[i+k][j] += 1 
            if ans[i+k][j] == 0:
                tmp.append([i+k, j])
                ans[i+k][j] = ans[i][j] + 1 
            k+=1
        k = 1
        while i + k < n and j+k < m and isvisit[i+k][j+k] != -1 and (isvisit[i+k][j+k] >> 1)^1:
            isvisit[i+k][j+k] += 1 << 1
            if ans[i+k][j+k] == 0:
                tmp.append([i+k, j+k])
                ans[i+k][j+k] = ans[i][j] + 1 
            k+=1
        k = 1
        while j+k < m and isvisit[i][j+k] != -1 and (isvisit[i][j+k] >> 2)^1:
            isvisit[i][j+k] += 1 << 2
            if ans[i][j+k] == 0:
                tmp.append([i, j+k])
                ans[i][j+k] = ans[i][j] + 1 
            k+=1 
```

滚动数组写法

```java

        dp[0][0]=1;
        for (int i = 1; i <= num; i++) {
            Arrays.fill(d[i&1],0);//记得清零因为后面要用到+=，就算是后面直接=也要清0，防止意外
            for (int j = 0; j <= boss; j++) {
                for (int k = 1; k <= 6; k++) {
                    dp[i&1][j]+=dp[1-i&1][Math.max(j-k,0)];//dp[i&1][j]和dp[1-i&1][j]分别表示0和1/1和0
                }
            }
        }
```

