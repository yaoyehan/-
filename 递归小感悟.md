```
//如果想要递归下去后出现true、false，那么就一路返回上去，可以使用
public boolean dfs(){
	if(dfs()){
		return true/false;
	}
}

//在递归过程中如果有多个分支，可以使用这种写法
public boolean dfs(){
	if(判断条件){
		dfs();
	}
	if(判断条件){
		dfs();
	}
//或者
	for(){
		dfs()
	}
}
//把上面两个结合起来我们可以这么写
public boolean dfs(){
	if(dfs()){
		return true/false;
	}
	if(dfs()){
		return true/false;
	}
//上面两种情况都拦不住你？那么我直接返回false/true
	return false/true;
}
```

```
https://leetcode.cn/problems/2bCMpM/下面例题题目
在使用记忆数组的时候，如果使用了数组表示走过的路径，也就是说走过的路径不让再次走，那么在子函数计算最佳结果时会受到之前走过的路不能再走的干扰，也就是说无法求出从当前位置出发的最优解，那既然没有最优解也就不能用记忆数组保存。（当然比如像下面这个例题，理论上我需要遍历所有结点为开始结点，然后递归深搜，我可以在这些结点得到结果后记录，而不是在子函数中记录，那么就没有问题，比较这些结点开始走时是四个方向都可以走的，也就是没有记录过哪怕一个已经走过的路线，那么就不会出现影响，还有一个问题就是假设在计算过程中走不通的用integer的最大值，那么由于所走过的路径不能走，很可能出现四个方向都走不了的情况，那么就会出现返回最大值，也就是当前位置距离0无穷大，走不通的意思，那么返回给上一个调用者，调用者再+1（+1表示加上当前位置）就会出现溢出情况，溢出后是负数，负数就尴尬了，取最小的时候取到负数，那结果就彻底乱了）
0 0 0 0 0 
1 1 1 1 1
1 1 1 1 1
比如我从i=1.j=2的位置出发，那么我先向下走，此时当前位置已经为走过，那么向下也就是i=2，j=2的位置就会收到之前那个位置不能走的影响而影响了最终要维护的最优解。
```

```
一般情况下使用深度优先搜索是为了找出所有可能性，比如从一个地方走到另一地方有多少条路线，但是广度优先搜索是为了找到最优解，所以在找最优解的时候用递归深搜很可能会导致超出时间限制。还有一点，实际上对于广度优先搜索来说，一般你是能找到为数不多的几个起点，然后由这些点推导出其他点，直到得到结果，而没有起始点，或者说遍历所有起始点的题目，那么可以使用深搜再加记忆数组，当然记忆数组不能乱用，比如说题目要求从大到小往下走，那么我不需要记录走过的结点，那么子递归就不会收到记录走过的结点这一种操作的影响，可以直接记忆。
```

```
注意点：递归深搜时需要注意，所有方向都要走到，假设条件是上下左右斜角都能走，你想着反正我从左往右从上往下，那父节点只需要走下面几个方向就好，因为上面几个方向肯定走不通，走通了就意味着我这个点已经被其他人遍历了，那我也不需要遍历，这个想法表面看没有问题，但是忘记考虑子节点了，子节点需要的是八个方向都走去找到答案，父节点只走四个方向关我什么事，所以由于子节点的限制，父节点其实八个方向都要写，只是说如果走过就不走了就好。
```

```
感悟1：广度优先搜索最好不要用来找最长距离，最短倒是可以，比如说我有一条路线1-》2-》3—》4，还有1-》5-》4，一般在广度优先搜索的时候要记录一下走过的路线，避免走环，这就意味着我们需要记忆，但是记忆是对于全局而言的，也就是说如果我在走到4的时候记录一下4已经走过了，由于1-5-4这条路线先走到4，导致了1234这条路线走不了4，那么就会出现问题，所以如果我们只是对单条路线进行记忆，又太过的麻烦，所以寻找最长路线的话我们还是用递归好一些，如果是最短路线的话用记忆+广度还是没有问题的。
```

