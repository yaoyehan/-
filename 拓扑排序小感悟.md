```
本人惊讶的发现那种有顺序的，比如先祈祷后锄地，先锄地后播种、祷告的题，要求最终一套流程的顺序的题可以使用拓扑排序来写，比如
祈祷：锄地，
锄地：播种，祷告
打滚：撒泼
广度优先：
所以我们首先得把数据使用hashmap包装成上面的样子，然后在包装过程中还需要有一个数组记录每一种行为的入度，比如祈祷之后是锄地，那么锄地的入度就+1，入度为0的第一个干，我们需要把所有入度为0的放入栈中，一个个取出，当遍历到某个行为如祈祷时，将其之后的所有行为入度-1，如果有入度为0的，就放入第一个动作（表示没人比我先了）。
深度优先
那我们可以随便一个开始，然后看看他后面跟着啥动作，然后后面那个动作又跟着什么动作，直到一个动作后没有其他动作为止，那么它就是最后的动作（当然祈祷，锄地，撒泼每个都要当一遍起始点，不然只从祈祷开始会少掉打滚，撒泼没有计算）最后一个出度为0，也就是他后续没有其他操作了，那么就放入结果集中的最后一位。
例题：课程选择
https://leetcode.cn/problems/QA2IGt/
结论：广度是先保存的是入度为0的，深度先保存的是出度为0的
```

