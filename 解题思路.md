1、将所有学过的如dp，dfs，bfs、前缀和等等先带入看看能不能解

2、上面不可用，可能是规律题：找出提出中的规律

3、改全局思路为局部思路，

![image-20231127230642349](D:\typora\笔记\习题笔记\imagesr\image-20231127230642349.png)

如果这题还是以全局思维去看，两两对比时间复杂度就会很高

所以应该改为局部思路，统计每个数字出现 的次数，然后用（k*（n-1）-Ck2）/Cn2就可以得到结果

4、遇到那种求子区间的题目，除了可以使用上面的3思路去解之外，还可以使用走一步存一步的思想，比如：我要求出一个数组中，所有连续子区间内的值相或后有多少个不同的值，那我就可以走一步把前面所有的值存到set里面，与当前值相或得到结果。基本代码如下：

```java
 for (int i = 0; i < n; i++) {
            HashSet<Integer> cur = new HashSet<>();
            for (int item : pre) {
                cur.add(item|a[i]);
            }
            cur.add(a[i]);
            res.addAll(cur);
            pre = cur;
 }
```

4、上面还不可用：可能是模拟题：直接模拟

5、实在还是不行那就以能想到的暴力方式解决（说不定就是那么无脑呢!!!）

比如

反向思维：比如要我从i+1开始的数组中找到大于当前value[i]的所有数中的最小值，我们从左往右那就得每走一个数减去一个数，你会发现如果用TreeSet的ceiling等方法求出大于当前value[i]的最小值好像可以，但是有一个问题，TreeSet不能指定删某个数，那怎么办，你从后往前走不就得了，把删除思路改为增加思路。

解题的时候可以合理使用封装方法或数据结构快速答题，比如说要求大于(等于)/小于(等于)某个数的第一个数字，我们第一个要想到TreeSet。或者用Array.binarySearch()方法实现二分查找

样例部分通过的解决办法：
在非超时问题时，我们应该想到常见的问题有：

1、数组异常异常

2、数据超出int导致的结果错误